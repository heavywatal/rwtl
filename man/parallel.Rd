% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parallel.R
\name{map_par}
\alias{map_par}
\alias{map_par_df}
\alias{invoke_par}
\title{purrr::map-like function in parallel}
\usage{
map_par(.x, .f, ..., .combine, .multicombine = TRUE, .inorder = TRUE,
  .packages = NULL, .export = NULL, .cores = parallel::detectCores(logical
  = FALSE), .cluster = c("FORK", "PSOCK"), .errorhandling = c("stop",
  "remove", "pass"))

map_par_df(.x, .f, ..., .id = NULL, .multicombine = TRUE, .inorder = TRUE,
  .packages = NULL, .export = NULL, .cores = parallel::detectCores(logical
  = FALSE), .cluster = c("FORK", "PSOCK"), .errorhandling = c("stop",
  "remove", "pass"))

invoke_par(.f, .x, ..., .env = NULL, .combine, .multicombine = TRUE,
  .inorder = TRUE, .packages = NULL, .export = NULL,
  .cores = parallel::detectCores(logical = FALSE), .cluster = c("FORK",
  "PSOCK"))
}
\arguments{
\item{.x}{A list or atomic vector.}

\item{.f}{A function, formula, or atomic vector.

  If a \strong{function}, it is used as is.

  If a \strong{formula}, e.g. \code{~ .x + 2}, it is converted to a
  function with two arguments, \code{.x} or \code{.} and \code{.y}. This
  allows you to create very compact anonymous functions with up to
  two inputs.

  If \strong{character} or \strong{integer vector}, e.g. \code{"y"}, it
  is converted to an extractor function, \code{function(x) x[["y"]]}. To
  index deeply into a nested list, use multiple values; \code{c("x", "y")}
  is equivalent to \code{z[["x"]][["y"]]}. You can also set \code{.null}
  to set a default to use instead of \code{NULL} for absent components.}

\item{...}{Additional arguments passed on to \code{.f}.}

\item{.combine}{function that is used to process the tasks results as
    they generated.  This can be specified as either a function or
    a non-empty character string naming the function.
    Specifying 'c' is useful for concatenating the results into
    a vector, for example.  The values 'cbind' and 'rbind' can combine
    vectors into a matrix.  The values '+' and '*' can be used to
    process numeric data.
    By default, the results are returned in a list.}

\item{.multicombine}{logical flag indicating whether the \code{.combine}
    function can accept more than two arguments.
    If an arbitrary \code{.combine} function is specified, by default,
    that function will always be called with two arguments.
    If it can take more than two arguments, then setting \code{.multicombine}
    to \code{TRUE} could improve the performance.
    The default value is \code{FALSE} unless the \code{.combine}
    function is \code{cbind}, \code{rbind}, or \code{c}, which are known
    to take more than two arguments.}

\item{.inorder}{logical flag indicating whether the \code{.combine}
    function requires the task results to be combined in the same order
    that they were submitted.  If the order is not important, then it
    setting \code{.inorder} to \code{FALSE} can give improved performance.
    The default value is \code{TRUE}.}

\item{.packages}{character vector of packages that the tasks depend on.
    If \code{ex} requires a \code{R} package to be loaded, this option
    can be used to load that package on each of the workers.
    Ignored when used with \code{\%do\%}.}

\item{.export}{character vector of variables to export.
    This can be useful when accessing a variable that isn't defined in the
    current environment.
    The default value in \code{NULL}.}

\item{.cores}{integer}

\item{.cluster}{type of parallel::makeCluster()}

\item{.errorhandling}{specifies how a task evalution error should be handled.
    If the value is "stop", then execution will be stopped via
    the \code{stop} function if an error occurs.
    If the value is "remove", the result for that task will not be
    returned, or passed to the \code{.combine} function.
    If it is "pass", then the error object generated by task evaluation
    will be included with the rest of the results.  It is assumed that
    the combine function (if specified) will be able to deal with the
    error object.
    The default value is "stop".}

\item{.id}{If not \code{NULL} a variable with this name will be created
giving either the name or the index of the data frame.}

\item{.env}{Environment in which \code{\link{do.call}()} should
evaluate a constructed expression. This only matters if you pass
as \code{.f} the name of a function rather than its value, or as
\code{.x} symbols of objects rather than their values.}
}
\value{
list

tibble

list
}
\description{
purrr::map-like function in parallel

purrr::map_df-like function in parallel

purrr::invoke-like function in parallel
}
