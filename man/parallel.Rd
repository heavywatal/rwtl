% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parallel.R
\name{map_par}
\alias{map_par}
\alias{map_par_dfr}
\alias{invoke_par}
\alias{mcmap}
\alias{mcmap_lgl}
\alias{mcmap_int}
\alias{mcmap_dbl}
\alias{mcmap_chr}
\alias{mcmap_dfr}
\title{Parallel execution in the purrr::map style}
\usage{
map_par(.x, .f, ..., .combine, .multicombine = TRUE, .inorder = TRUE,
  .packages = NULL, .export = NULL, .mc.cores = getOption("mc.cores",
  2L), .cluster = c("FORK", "PSOCK"), .errorhandling = c("stop",
  "remove", "pass"))

map_par_dfr(.x, .f, ..., .id = NULL, .multicombine = TRUE,
  .inorder = TRUE, .packages = NULL, .export = NULL,
  .mc.cores = getOption("mc.cores", 2L), .cluster = c("FORK", "PSOCK"),
  .errorhandling = c("stop", "remove", "pass"))

invoke_par(.f, .x, ..., .env = NULL, .combine, .multicombine = TRUE,
  .inorder = TRUE, .packages = NULL, .export = NULL,
  .mc.cores = getOption("mc.cores", 2L), .cluster = c("FORK", "PSOCK"))

mcmap(.x, .f, ..., .mc.cores = getOption("mc.cores", 2L))

mcmap_lgl(.x, .f, ..., .mc.cores = getOption("mc.cores", 2L))

mcmap_int(.x, .f, ..., .mc.cores = getOption("mc.cores", 2L))

mcmap_dbl(.x, .f, ..., .mc.cores = getOption("mc.cores", 2L))

mcmap_chr(.x, .f, ..., .mc.cores = getOption("mc.cores", 2L))

mcmap_dfr(.x, .f, ..., .id = NULL, .mc.cores = getOption("mc.cores",
  2L))
}
\arguments{
\item{.x}{A list or atomic vector.}

\item{.f}{A function, formula, or atomic vector.

If a \strong{function}, it is used as is.

If a \strong{formula}, e.g. \code{~ .x + 2}, it is converted to a function. There
are three ways to refer to the arguments:
\itemize{
\item For a single argument function, use \code{.}
\item For a two argument function, use \code{.x} and \code{.y}
\item For more arguments, use \code{..1}, \code{..2}, \code{..3} etc
}

This syntax allows you to create very compact anonymous functions.

If \strong{character vector}, \strong{numeric vector}, or \strong{list}, it
is converted to an extractor function. Character vectors index by name
and numeric vectors index by position; use a list to index by position
and name at different levels. Within a list, wrap strings in \code{\link[=get-attr]{get-attr()}}
to extract named attributes. If a component is not present, the value of
\code{.default} will be returned.}

\item{...}{Additional arguments passed on to \code{.f}.}

\item{.combine}{function that is used to process the tasks results as
    they generated.  This can be specified as either a function or
    a non-empty character string naming the function.
    Specifying 'c' is useful for concatenating the results into
    a vector, for example.  The values 'cbind' and 'rbind' can combine
    vectors into a matrix.  The values '+' and '*' can be used to
    process numeric data.
    By default, the results are returned in a list.}

\item{.multicombine}{logical flag indicating whether the \code{.combine}
    function can accept more than two arguments.
    If an arbitrary \code{.combine} function is specified, by default,
    that function will always be called with two arguments.
    If it can take more than two arguments, then setting \code{.multicombine}
    to \code{TRUE} could improve the performance.
    The default value is \code{FALSE} unless the \code{.combine}
    function is \code{cbind}, \code{rbind}, or \code{c}, which are known
    to take more than two arguments.}

\item{.inorder}{logical flag indicating whether the \code{.combine}
    function requires the task results to be combined in the same order
    that they were submitted.  If the order is not important, then it
    setting \code{.inorder} to \code{FALSE} can give improved performance.
    The default value is \code{TRUE}.}

\item{.packages}{character vector of packages that the tasks depend on.
    If \code{ex} requires a \code{R} package to be loaded, this option
    can be used to load that package on each of the workers.
    Ignored when used with \code{\%do\%}.}

\item{.export}{character vector of variables to export.
    This can be useful when accessing a variable that isn't defined in the
    current environment.
    The default value in \code{NULL}.}

\item{.mc.cores}{integer}

\item{.cluster}{type of parallel::makeCluster()}

\item{.errorhandling}{specifies how a task evalution error should be handled.
    If the value is "stop", then execution will be stopped via
    the \code{stop} function if an error occurs.
    If the value is "remove", the result for that task will not be
    returned, or passed to the \code{.combine} function.
    If it is "pass", then the error object generated by task evaluation
    will be included with the rest of the results.  It is assumed that
    the combine function (if specified) will be able to deal with the
    error object.
    The default value is "stop".}

\item{.id}{If not \code{NULL} a variable with this name will be created
giving either the name or the index of the data frame.}

\item{.env}{Environment in which \code{\link[=do.call]{do.call()}} should
evaluate a constructed expression. This only matters if you pass
as \code{.f} the name of a function rather than its value, or as
\code{.x} symbols of objects rather than their values.}
}
\description{
\code{map_par}, \code{map_par_dfr}, and \code{invoke_par} are shortcuts to make a cluster
and use it with \code{foreach::foreach}.

\code{mcmap} is a variant of \code{parallel::mclapply} that accepts a formula as \code{.f}.
}
